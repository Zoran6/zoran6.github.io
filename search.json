[{"title":"Redis的主从、哨兵以及集群部署","path":"/2025/07/24/redis-deploy/","content":"时间：2025年7月24日23:41:01 一、Redis安装步骤（Linux系统） 安装依赖 sudo apt-get updatesudo apt-get install build-essential tcl 下载并编译Redis wget https://download.redis.io/releases/redis-6.2.6.tar.gztar xzf redis-6.2.6.tar.gzcd redis-6.2.6make sudo make install 创建系统目录 sudo mkdir /etc/redis /var/lib/redissudo cp redis.conf /etc/redis/ 创建Systemd服务创建文件 /etc/systemd/system/redis.service： [Unit]Description=Redis In-Memory Data StoreAfter=network.target[Service]ExecStart=/usr/local/bin/redis-server /etc/redis/redis.confRestart=alwaysUser=redisGroup=redis[Install]WantedBy=multi-user.target 创建用户并授权： sudo adduser --system --group --no-create-home redissudo chown -R redis:redis /var/lib/redis 启动Redis sudo systemctl daemon-reloadsudo systemctl start redissudo systemctl enable redis 二、配置文件参数含义（redis.conf关键项） 参数 说明 bind 0.0.0.0 允许所有IP访问，生产环境建议绑定具体IP port 6379 服务监听端口 daemonize yes 以守护进程模式运行 dir /var/lib/redis 数据持久化目录 requirepass 123456 设置连接密码（建议启用） maxmemory 2gb 最大内存限制（根据服务器调整） appendonly yes 启用AOF持久化（推荐） replicaof 从节点配置主节点地址（主从复制使用） protected-mode no 关闭保护模式（需配合密码和绑定IP使用） 三、两台服务器主从复制部署方案架构：1主 + 1从目标：主节点写，从节点读，数据自动同步。 步骤： 主节点配置（10.0.0.1）修改 /etc/redis/redis.conf： bind 10.0.0.1requirepass masterpass 从节点配置（10.0.0.2）修改 /etc/redis/redis.conf： bind 10.0.0.2replicaof 10.0.0.1 6379masterauth masterpass # 主节点密码 重启服务 sudo systemctl restart redis 验证主从在主节点执行： redis-cli -h 10.0.0.1 -a masterpass INFO replication # 查看Replication角色为master 在从节点执行： INFO replication # 查看Replication角色为slave 四、三台服务器哨兵模式部署方案架构：3哨兵（Sentinel）目标：主节点故障时自动选举新主节点，实现高可用。 步骤： 部署主从复制按三、 步骤配置主（10.0.0.1）和从（10.0.0.2）。 配置哨兵（三台服务器均部署）创建配置文件 /etc/redis/sentinel.conf： port 26379sentinel monitor mymaster 10.0.0.1 6379 2sentinel auth-pass mymaster masterpasssentinel down-after-milliseconds mymaster 5000sentinel failover-timeout mymaster 10000daemonize yes 启动哨兵 redis-sentinel /etc/redis/sentinel.conf 验证故障转移 手动停止主节点Redis服务。 观察哨兵日志，确认从节点提升为新主节点。 原主恢复后自动成为新主节点的从节点。 五、集群部署方案（三主三从）架构：6节点（3主 + 3从），每个主节点有1个从节点。目标：数据分片存储，支持高并发与高可用。 步骤： 所有节点配置修改每个节点的 /etc/redis/redis.conf： cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000appendonly yes 启动所有节点 sudo systemctl restart redis 创建集群在一台服务器执行（需安装ruby）： redis-cli --cluster create \\ 10.0.0.1:6379 10.0.0.2:6379 10.0.0.3:6379 \\ 10.0.0.4:6379 10.0.0.5:6379 10.0.0.6:6379 \\ --cluster-replicas 1 -a masterpass 验证集群 redis-cli -c -a masterpass CLUSTER INFO # 查看集群状态 CLUSTER NODES # 查看节点拓扑 关键注意事项 防火墙：开放Redis端口（6379）和哨兵端口（26379）。 生产建议： 使用非默认端口 启用强密码认证 监控内存和连接数 备份策略：定期RDBAOF备份到云存储。 以上方案基于Redis 6.x，实际部署时请根据环境调整参数。","tags":["redis"],"categories":["Linux","Redis"]},{"title":"Oracle迁移TDSQL-语法转换篇","path":"/2025/07/23/OracleToTXSQL/","content":"因为TDSQL兼容MySQL的语法，所以下文中用MySQL的语法替代TDSQL，本文重点关注语法转换。 一、 基础语法差异与迁移 字符串连接： Oracle: || (例如 SELECT Hello || World FROM dual;) MySQL: CONCAT() 函数 (例如 SELECT CONCAT(Hello, World);)。|| 在MySQL中默认是逻辑OR运算符（除非设置SQL_MODE=PIPES_AS_CONCAT，但不推荐依赖此设置）。 迁移： 将所有 || 替换为 CONCAT()。 空字符串与NULL： Oracle: 严格区分空字符串()和NULL。 MySQL: 不严格区分。在大多数上下文中（特别是使用=或比较时），空字符串()被视为等同于NULL。但使用IS NULL和IS NOT NULL时能区分。 迁移： 这是最容易出错的地方！ 仔细检查所有使用 column = 或 column 的条件。通常需要改为 column IS NULL 或 (column IS NULL OR column = ) 或 (column IS NOT NULL AND column )，具体逻辑取决于Oracle中的原始意图。 检查NVLNVL2等处理空值的函数逻辑，确保在MySQL中达到相同效果（MySQL的IFNULLCOALESCE处理NULL，不处理空串）。 伪表 DUAL： Oracle: SELECT SYSDATE FROM dual; SELECT 1+1 FROM dual; (DUAL是单行单列虚拟表) MySQL: SELECT NOW(); SELECT 1+1; (可以直接执行，不需要FROM子句) 迁移： 删除不必要的 FROM dual。 分页查询： Oracle 12c 之前: 使用 ROWNUM 和子查询实现复杂分页。 Oracle 12c+: 使用 OFFSET ... FETCH ...。 MySQL: 使用 LIMIT [offset,] row_count 或 LIMIT row_count OFFSET offset。 迁移： 将Oracle 12c+的 OFFSET ... FETCH ... 直接替换为MySQL的 LIMIT ... OFFSET ... 语法。 将Oracle 12c之前基于ROWNUM的复杂分页逻辑重写为使用LIMIT ... OFFSET ...。通常需要去掉外层包装的子查询。 日期和时间： 获取当前时间: Oracle: SYSDATE (精确到秒), SYSTIMESTAMP (精确到小数秒) MySQL: NOW() (返回DATETIME，精确到秒), CURRENT_TIMESTAMP() (同NOW()), SYSDATE() (每次调用实时获取，可能影响基于语句的复制和某些优化), CURDATE(), CURTIME()。推荐使用 NOW() 或 CURRENT_TIMESTAMP()。 日期加减: Oracle: date_column + INTERVAL 1 DAY, date_column - 7 MySQL: DATE_ADD(date_column, INTERVAL 1 DAY), DATE_SUB(date_column, INTERVAL 7 DAY) 或 date_column + INTERVAL 1 DAY, date_column - INTERVAL 7 DAY (MySQL也支持 +/- INTERVAL 语法，推荐)。 日期截断： Oracle: TRUNC(date_column) (到天), TRUNC(date_column, MM) (到月) MySQL: DATE(date_column) (提取日期部分), LAST_DAY(date_column) (月末), 对于其他截断通常使用 DATE_FORMAT(date_column, %Y-%m-01) (月初) 或组合函数。 日期格式化： Oracle: TO_CHAR(date_column, YYYY-MM-DD HH24:MI:SS) MySQL: DATE_FORMAT(date_column, %Y-%m-%d %H:%i:%s) (注意：%H是24小时制, %i是分钟) 字符串转日期： Oracle: TO_DATE(2023-10-27, YYYY-MM-DD) MySQL: STR_TO_DATE(2023-10-27, %Y-%m-%d) 迁移： 系统性地替换日期相关函数和运算符。特别注意格式模型的不同。 序列 (Sequence)： Oracle: 使用显式的SEQUENCE对象 (CREATE SEQUENCE ...), 通过 sequence_name.NEXTVAL 和 sequence_name.CURRVAL 访问。 MySQL: 使用 AUTO_INCREMENT 属性为主键列自动生成唯一ID (主要用于单表)。对于需要全局序列或多表共享序列，有以下方案： 方案A (推荐)： 创建一个专门的表来模拟序列 (包含 id AUTO_INCREMENT 字段)。通过 INSERT ... ; SELECT LAST_INSERT_ID(); 获取新值。需要小心并发和事务管理。 方案B： 使用MySQL 8.0+的 AUTO_INCREMENT 的持久化特性（innodb_autoinc_lock_mode=2 - interleaved lock mode）结合 LAST_INSERT_ID()，但这主要解决批量插入的间隙问题，不完全等同于独立序列。 方案C (谨慎)： 使用第三方工具或自定义函数。 迁移： 对于主键，优先使用AUTO_INCREMENT。对于非主键序列需求，采用方案A（模拟序列表）并重写所有 NEXTVALCURRVAL 的访问逻辑。 数据类型映射： 常用映射: NUMBER(p, s) - DECIMAL(p, s) (精确数值) VARCHAR2(n [CHAR|BYTE]) - VARCHAR(n) (MySQL的VARCHAR长度指字符数，需确认n是否足够，注意UTF8MB4字符可能占4字节) NVARCHAR2(n) - NVARCHAR(n) 或 VARCHAR(n) CHARACTER SET utf8mb4 (存储Unicode) DATE - DATETIME 或 DATE (Oracle DATE包含时间部分，MySQL DATE只有日期。如果需要时间，用DATETIME或TIMESTAMP) TIMESTAMP - TIMESTAMP (注意MySQL TIMESTAMP范围是’1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC, 且有时区转换行为) 或 DATETIME (范围’1000-01-01 00:00:00’到’9999-12-31 23:59:59’, 无时区转换) CLOB - LONGTEXT BLOB - LONGBLOB RAW(n) - VARBINARY(n) LONG - LONGTEXT 或 LONGBLOB (已废弃类型) 迁移： 根据实际存储内容和需求仔细选择最合适的MySQL类型。特别注意日期时间类型的选择和TIMESTAMP的范围限制。 二、 函数映射与替换 空值处理： NVL(expr1, expr2) - IFNULL(expr1, expr2) 或 COALESCE(expr1, expr2) NVL2(expr1, expr2, expr3) - IF(expr1 IS NOT NULL, expr2, expr3) 或 CASE WHEN expr1 IS NOT NULL THEN expr2 ELSE expr3 END COALESCE(expr1, expr2, ..., exprn) (两者都有，语法相同) 条件逻辑： DECODE(value, search1, result1, search2, result2, ..., default) - CASE value WHEN search1 THEN result1 WHEN search2 THEN result2 ... ELSE default END CASE ... END (两者语法基本相同，是首选) 字符串函数： SUBSTR(string, start [, length]) - SUBSTRING(string, start [, length]) (注意：Oracle的start可为负表示从末尾数，MySQL也支持负数start) INSTR(string, substring [, start [, occurrence]]) - LOCATE(substring, string [, start]) (MySQL的LOCATE只返回第一次出现的位置，要模拟occurrence需要更复杂逻辑或自定义函数) LENGTH(string) - CHAR_LENGTH(string) 或 LENGTH(string) (Oracle LENGTH按字符数，MySQL LENGTH()按字节数, CHAR_LENGTH()按字符数。强烈推荐在涉及多字节字符集时使用CHAR_LENGTH()) LPAD(string, length [, pad_string]) RPAD(...) (两者都有，语法相同) UPPER(string) LOWER(string) (两者都有，语法相同) TRIM([[LEADING|TRAILING|BOTH] trim_character FROM] string) (两者语法基本相同) REPLACE(string, search_string, replacement_string) (两者都有，语法相同) 聚合函数： COUNT, SUM, AVG, MIN, MAX (两者语法基本相同) LISTAGG(measure_expr [, delimiter]) WITHIN GROUP (ORDER BY sort_expr) - GROUP_CONCAT([DISTINCT] expr [, separator] [ORDER BY ... [ASC|DESC]]) (注意排序和分隔符位置语法差异) 分析函数 (窗口函数)： Oracle有丰富的分析函数 (ROW_NUMBER(), RANK(), DENSE_RANK(), LEAD(), LAG(), SUM() OVER(), ...) MySQL 8.0+ 已支持标准SQL窗口函数，语法与Oracle高度相似。 这是迁移到MySQL 8.0+的巨大优势！ 迁移： 如果使用MySQL 8.0+，大部分分析函数可以直接迁移或做极小语法调整（如别名引用）。如果使用MySQL 5.7或更低版本，需要彻底重写为使用变量(@var)模拟或复杂的自连接子查询，工作量巨大且性能可能不佳。强烈建议升级到MySQL 8.0+以支持窗口函数。 其他常用函数： TO_CHAR(number/date, format) - 数字: FORMAT(number, decimals) (注意返回字符串带千分位) 或 CAST(number AS CHAR)；日期: DATE_FORMAT(date, format) TO_NUMBER(string) - CAST(string AS DECIMAL) 或 CONVERT(string, DECIMAL) SYSDATE - NOW() 或 CURRENT_TIMESTAMP() ADD_MONTHS(date, n) - DATE_ADD(date, INTERVAL n MONTH) MONTHS_BETWEEN(date1, date2) - 需计算：TIMESTAMPDIFF(MONTH, date2, date1) + 调整 (注意Oracle结果含小数部分表示不足月的天数差异，精确模拟较复杂) LAST_DAY(date) (两者都有) NEXT_DAY(date, DAYOFWEEK) - 需要计算：DATE_ADD(date, INTERVAL (7 - WEEKDAY(date) + CASE WHEN target_dow_index WEEKDAY(date) THEN target_dow_index - WEEKDAY(date) ELSE 7 - WEEKDAY(date) + target_dow_index END) DAY) (很复杂，通常建议应用层处理或自定义函数) DBMS_RANDOM.VALUE - RAND() (生成0-1随机浮点数) 三、 高级特性与对象迁移 存储过程、函数、包： 语法差异巨大： PLSQL (Oracle) vs MySQL的存储过程语言（基于SQLPSM）。包(Package)在MySQL中没有直接对应概念。 迁移策略： 重构： 这是最彻底但也最耗时的方式。将Oracle的PLSQL代码（尤其是使用了大量Oracle特有函数、特性、游标、异常处理的代码）用MySQL的存储过程函数语法重写。 分解包： 将Oracle包中的存储过程、函数、变量、游标定义拆分到独立的MySQL存储过程、函数、临时表会话变量中。 工具转换+人工重写： 使用迁移工具进行初步转换，然后投入大量精力进行人工审查、测试和重写。 业务逻辑上移： 考虑是否可以将部分逻辑移到应用层代码中实现，减少对数据库存储过程的依赖。 触发器： 语法 (CREATE TRIGGER ... BEFORE/AFTER ... ON ... FOR EACH ROW ...) 基本相似。 迁移注意点： 替换触发器内部使用的Oracle特有函数和语法（如 :NEW, :OLD 引用新旧行在MySQL中写法相同）。 注意MySQL的触发器不允许在触发器中调用存储过程（MySQL 5.7及之前）或对本表进行修改（可能导致递归循环）。MySQL 8.0允许在触发器中调用存储过程。 仔细测试触发器逻辑，确保在MySQL中行为一致。 视图： 语法 (CREATE VIEW ... AS SELECT ...) 基本相同。 迁移： 主要工作是确保视图定义中的SQL语句本身（涉及到的表、列、函数、条件）在MySQL中能正确执行并返回预期结果。替换其中的Oracle特有语法和函数。 索引与约束： 主键、外键、唯一约束、非空约束： 语法 (PRIMARY KEY, FOREIGN KEY ... REFERENCES ..., UNIQUE, NOT NULL) 基本相同，迁移时保留即可。 检查约束： Oracle支持，MySQL直到8.0.16才真正支持标准的CHECK约束（之前版本会解析但忽略）。迁移到MySQL 8.0.16+： 可以迁移CHECK约束。迁移到更低版本： 约束逻辑需要通过触发器或在应用层实现。 函数索引： Oracle支持。MySQL 8.0.13+支持在InnoDB上创建函数索引（称为Generated Columns Index）。迁移策略： 如果使用MySQL 8.0.13+，可以考虑使用Generated Column+索引模拟。否则，需要重写查询避免在WHERE条件中对列使用函数。 事务与锁： 基本语法 (START TRANSACTION, COMMIT, ROLLBACK, SAVEPOINT) 相同。 隔离级别： Oracle默认通常是READ COMMITTED。 MySQL InnoDB默认是REPEATABLE READ。行为有显著差异！ (如MySQL RR通过快照避免不可重复读和幻读，Oracle RC可能遇到)。迁移： 评估应用对隔离级别的依赖。可以在MySQL连接会话或全局设置隔离级别 (SET TRANSACTION ISOLATION LEVEL READ COMMITTED;)。务必进行并发测试。 锁机制： 两者都是基于锁+MVCC。理解差异对于高性能应用很重要，但SQL语法层面通常不需要修改。 层次查询 (CONNECT BY)： Oracle: 使用 START WITH ... CONNECT BY [PRIOR] ... 进行递归查询。 MySQL 8.0+: 使用标准SQL的递归公用表表达式 WITH RECURSIVE cte_name AS (...) SELECT ... FROM cte_name。 迁移： 如果使用MySQL 8.0+，将CONNECT BY查询重写为WITH RECURSIVE语法。这是结构性的重写，需要理解递归CTE原理。低版本MySQL无内置支持，需要应用层递归或使用存储过程模拟，非常复杂。 四、 字符集与排序规则 Oracle: 常用AL32UTF8 (UTF-8)。 MySQL: 强烈推荐使用 utf8mb4 字符集和 utf8mb4_0900_ai_ci (或合适的) 排序规则。 utf8mb4 是真正的UTF-8，支持4字节字符（如emoji表情）。 MySQL旧的utf8只支持3字节字符（已废弃）。 迁移： 确保在MySQL服务器、数据库、表和连接字符串中都明确指定使用 utf8mb4 和合适的排序规则 (collation)。排序规则影响字符串比较和排序规则，需根据业务需求选择（如是否区分大小写 _ci_cs，是否区分重音 _ai_as）。测试字符数据的正确存储、检索和比较。 关键挑战与注意事项 存储过程包高级函数： 最大的技术难点，需要深入理解两边语法和特性，可能涉及大量重写。 隐式行为差异： 空字符串NULL、日期处理、隐式类型转换、默认隔离级别等，容易在测试中遗漏，导致生产环境问题。 性能调优： MySQL的优化器、锁机制、执行计划可能与Oracle不同。迁移后必须进行性能测试和优化（索引、查询重写、参数调整）。 事务与并发控制： 理解REPEATABLE READ与READ COMMITTED的差异对应用并发逻辑的影响。 字符集与编码： 确保utf8mb4正确配置，避免乱码问题。 测试覆盖度： 测试不充分是迁移失败的主要原因。需要全面的测试计划和数据。 人员技能： 团队需要同时熟悉Oracle和MySQL（特别是MySQL 8.0的新特性）。 总结： Oracle迁移到MySQL在SQL层面是一个系统性的工程，涉及大量语法、函数和特性的映射、重写与适配。成功的关键在于深入理解差异、严格的测试、对复杂代码（特别是存储过程）的重点投入以及选择MySQL 8.0+版本。务必做好详细规划、风险评估和充分的测试验证。祝您迁移顺利！","tags":["sql"],"categories":["数据库国产化"]},{"title":"Podman容器化部署&运维","path":"/2025/07/13/almalinux-podman/","content":"podman简介podman vs dockerpodman常用命令DockerFile实际操作","tags":["linux","运维"],"categories":["Linux","Podman"]},{"title":"Almalinux9.6常用服务部署","path":"/2025/07/13/almalinux-base/","content":"虚拟机环境：Almalinux9.6 施工中…","tags":["linux"],"categories":["Linux"]},{"title":"SQL常用语法","path":"/2025/07/13/sql-base/","content":"施工中…","tags":["sql"],"categories":["SQL"]},{"title":"SQL批处理","path":"/2025/07/13/sql-batch/","content":"施工中","tags":["sql"],"categories":["SQL"]},{"title":"SQL中的递归CTE","path":"/2025/07/13/sql-cte/","content":"递归CTE简介基础用法实例操作","tags":["sql"],"categories":["SQL"]},{"title":"关于","path":"/about/index.html","content":"王卓有趣的牛马万里挑一 关于本站 我的笔尖，仅是浅滩的微光， 记录潮汐的絮语，礁石的形状。 这点滴的沙砾，汇不成大陆， 却愿作一粒引路的燧石。 本站建于2025年7月13日，正在慢慢转移资源…尽请期待！"},{"title":"收藏","path":"/bookmark/index.html","content":"…"},{"title":"探索","path":"/explore/index.html","content":"…"},{"title":"友链","path":"/friends/index.html","content":"友链关于小伙伴们如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。 [2023-12] 友链失联了怎么办? 添加友链后如果网站长期无法访问，可能会被取消友链！如果您的网站恢复了，可以在申请友链时创建的那条 issue 中评论告知。 朋友们近期的文章 如何交换友链？ 您的网站应满足以下全部条件： 安全合规：合法的、非营利性、无木马植入的 HTTPS 站点。 非空壳网站：网站内发布至少 五篇 原创文章，内容题材不限。 我们需要有一定的有效互动： 先友后链：与博主有至少 半年 的有效互动，例如 issue 或者评论留言。 [2023-12] 友链申请条件变更说明 降低了对商业广告的要求，可以有但是不能太多。提高了「有效互动」的定义：5次更改为半年。 我已满足全部条件，快告诉我如何交换友链！ 如果您没有满足上述条件，即时提交了申请也不会通过哦～ 第一步：新建 Issue新建 GitHub Issue 按照模板格式填写并提交。为了提高图片加载速度，建议优化头像：打开 压缩图 上传自己的头像，将图片尺寸调整到 144px 后下载。将压缩后的图片上传到 去不图床 或者其它稳定的图床并使用此图片链接作为头像。第二步：添加友链并等待管理员审核请添加本站到您的友链中：title: xxxurl: https://xxx.comavatar: screenshot: 待管理员审核通过，添加了 active 标签后，回来刷新即可生效。如果您需要更新自己的友链，请直接修改 issue 内容，大约 3 分钟内生效，无需等待博客重新部署。"},{"title":"Page","path":"/page/index.html","content":"This is a page test."},{"title":"朋友文章","path":"/friends/rss/index.html","content":""}]